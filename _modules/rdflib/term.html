
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>rdflib.term &#8212; mep-django 1.1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for rdflib.term</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the different types of terms. Terms are the kinds of</span>
<span class="sd">objects that can appear in a quoted/asserted triple. This includes those</span>
<span class="sd">that are core to RDF:</span>

<span class="sd">* :class:`Blank Nodes &lt;rdflib.term.BNode&gt;`</span>
<span class="sd">* :class:`URI References &lt;rdflib.term.URIRef&gt;`</span>
<span class="sd">* :class:`Literals &lt;rdflib.term.Literal&gt;` (which consist of a literal value,datatype and language tag)</span>

<span class="sd">Those that extend the RDF model into N3:</span>

<span class="sd">* :class:`Formulae &lt;rdflib.graph.QuotedGraph&gt;`</span>
<span class="sd">* :class:`Universal Quantifications (Variables) &lt;rdflib.term.Variable&gt;`</span>

<span class="sd">And those that are primarily for matching against &#39;Nodes&#39; in the</span>
<span class="sd">underlying Graph:</span>

<span class="sd">* REGEX Expressions</span>
<span class="sd">* Date Ranges</span>
<span class="sd">* Numerical Ranges</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;bind&#39;</span><span class="p">,</span>

    <span class="s1">&#39;Node&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Identifier&#39;</span><span class="p">,</span>

    <span class="s1">&#39;URIRef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;BNode&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Literal&#39;</span><span class="p">,</span>

    <span class="s1">&#39;Variable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Statement&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">xml.dom.minidom</span>

<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="k">import</span> <span class="n">urlparse</span><span class="p">,</span> <span class="n">urljoin</span><span class="p">,</span> <span class="n">urldefrag</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">re</span> <span class="k">import</span> <span class="n">sub</span><span class="p">,</span> <span class="nb">compile</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">isodate</span> <span class="k">import</span> <span class="n">parse_time</span><span class="p">,</span> <span class="n">parse_date</span><span class="p">,</span> <span class="n">parse_datetime</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">hashlib</span> <span class="k">import</span> <span class="n">md5</span>
    <span class="k">assert</span> <span class="n">md5</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">md5</span> <span class="k">import</span> <span class="n">md5</span>


<span class="kn">import</span> <span class="nn">rdflib</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">py3compat</span>
<span class="kn">from</span> <span class="nn">rdflib.compat</span> <span class="k">import</span> <span class="n">numeric_greater</span>


<span class="n">b</span> <span class="o">=</span> <span class="n">py3compat</span><span class="o">.</span><span class="n">b</span>

<span class="n">skolem_genid</span> <span class="o">=</span> <span class="s2">&quot;/.well-known/genid/&quot;</span>
<span class="n">rdflib_skolem_genid</span> <span class="o">=</span> <span class="s2">&quot;/.well-known/genid/rdflib/&quot;</span>
<span class="n">skolems</span> <span class="o">=</span> <span class="p">{}</span>


<span class="n">_invalid_uri_chars</span> <span class="o">=</span> <span class="s1">&#39;&lt;&gt;&quot; </span><span class="si">{}</span><span class="s1">|</span><span class="se">\\</span><span class="s1">^`&#39;</span>

<span class="k">def</span> <span class="nf">_is_valid_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">_invalid_uri_chars</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">uri</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="n">_lang_tag_regex</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="s1">&#39;^[a-zA-Z]+(?:-[a-zA-Z0-9]+)*$&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_valid_langtag</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_lang_tag_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_is_valid_unicode</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Verify that the provided value can be converted into a Python</span>
<span class="sd">    unicode object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">coding_func</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;decode&#39;</span><span class="p">),</span> <span class="s1">&#39;utf-8&#39;</span>
    <span class="k">elif</span> <span class="n">py3compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="n">coding_func</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coding_func</span><span class="p">,</span> <span class="n">param</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span>

    <span class="c1"># try to convert value into unicode</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">coding_func</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Node in the Graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>


<span class="k">class</span> <span class="nc">Identifier</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># allow Identifiers to be Nodes in the Graph</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See http://www.w3.org/2002/07/rdf-identifer-terminology/</span>
<span class="sd">    regarding choice of terminology.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A &quot;semantic&quot;/interpreted equality function,</span>
<span class="sd">        by default, same as __eq__&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">neq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A &quot;semantic&quot;/interpreted not equal function,</span>
<span class="sd">        by default, same as __ne__&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equality for Nodes.</span>

<span class="sd">        &gt;&gt;&gt; BNode(&quot;foo&quot;)==None</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; BNode(&quot;foo&quot;)==URIRef(&quot;foo&quot;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; URIRef(&quot;foo&quot;)==BNode(&quot;foo&quot;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; BNode(&quot;foo&quot;)!=URIRef(&quot;foo&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; URIRef(&quot;foo&quot;)!=BNode(&quot;foo&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Variable(&#39;a&#39;)!=URIRef(&#39;a&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Variable(&#39;a&#39;)!=Variable(&#39;a&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This implements ordering for Nodes,</span>

<span class="sd">        This tries to implement this:</span>
<span class="sd">        http://www.w3.org/TR/sparql11-query/#modOrderBy</span>

<span class="sd">        Variables are not included in the SPARQL list, but</span>
<span class="sd">        they are greater than BNodes and smaller than everything else</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># everything bigger than None</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)]</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Nothing is less than None</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">_ORDERING</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)]</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">fqn</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">fqn</span><span class="p">)</span> <span class="o">^</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">URIRef</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RDF URI Reference: http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ends_in_hash</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">urljoin</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">allow_fragments</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ends_in_hash</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">+=</span> <span class="s2">&quot;#&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_valid_uri</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> does not look like a valid URI, trying to serialize this will break.&#39;</span><span class="o">%</span><span class="n">value</span><span class="p">)</span>


        <span class="k">try</span><span class="p">:</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rt</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This will do a limited check for valid URIs,</span>
<span class="sd">        essentially just making sure that the string includes no illegal</span>
<span class="sd">        characters (``&lt;, &gt;, &quot;, {, }, |, \\, `, ^``)</span>

<span class="sd">        :param namespace_manager: if not None, will be used to make up</span>
<span class="sd">             a prefixed name</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_valid_uri</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot; does not look like a valid URI, I cannot serialize this as N3/Turtle. Perhaps you wanted to urlencode it?&#39;</span><span class="o">%</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">namespace_manager</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">namespace_manager</span><span class="o">.</span><span class="n">normalizeUri</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">defrag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;#&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">url</span><span class="p">,</span> <span class="n">frag</span> <span class="o">=</span> <span class="n">urldefrag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">URIRef</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">py3compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">URIRef</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">&quot;rdflib.term.URIRef&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">URIRef</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">%</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">md5_term_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a string of hex that will be the same for two URIRefs that</span>
<span class="sd">        are the same. It is not a suitable unique id.</span>

<span class="sd">        Supported for backwards compatibility; new code should</span>
<span class="sd">        probably just use __hash__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;method md5_term_hash is deprecated, and will be removed &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;in the future. If you use this please let rdflib-dev know!&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">de_skolemize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a Blank Node from a skolem URI, in accordance</span>
<span class="sd">        with http://www.w3.org/TR/rdf11-concepts/#section-skolemization.</span>
<span class="sd">        This function accepts only rdflib type skolemization, to provide</span>
<span class="sd">        a round-tripping within the system.</span>

<span class="sd">        .. versionadded:: 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RDFLibGenid</span><span class="p">):</span>
            <span class="n">parsed_uri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BNode</span><span class="p">(</span>
                <span class="n">value</span><span class="o">=</span><span class="n">parsed_uri</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rdflib_skolem_genid</span><span class="p">):])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Genid</span><span class="p">):</span>
            <span class="n">bnode_id</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="n">bnode_id</span> <span class="ow">in</span> <span class="n">skolems</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">skolems</span><span class="p">[</span><span class="n">bnode_id</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retval</span> <span class="o">=</span> <span class="n">BNode</span><span class="p">()</span>
                <span class="n">skolems</span><span class="p">[</span><span class="n">bnode_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">retval</span>
                <span class="k">return</span> <span class="n">retval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt; is not a skolem URI&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Genid</span><span class="p">(</span><span class="n">URIRef</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_external_skolem</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">uri</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="n">parsed_uri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="n">gen_id</span> <span class="o">=</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">skolem_genid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gen_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">RDFLibGenid</span><span class="p">(</span><span class="n">Genid</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_rdflib_skolem</span><span class="p">(</span><span class="n">uri</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">uri</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="n">parsed_uri</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">params</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> \
                <span class="ow">or</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">query</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> \
                <span class="ow">or</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">fragment</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">gen_id</span> <span class="o">=</span> <span class="n">parsed_uri</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">rdflib_skolem_genid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gen_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_unique_id</span><span class="p">():</span>
    <span class="c1"># Used to read: &quot;&quot;&quot;Create a (hopefully) unique prefix&quot;&quot;&quot;</span>
    <span class="c1"># now retained merely to leave interal API unchanged.</span>
    <span class="c1"># From BNode.__new__() below ...</span>
    <span class="c1">#</span>
    <span class="c1"># acceptable bnode value range for RDF/XML needs to be</span>
    <span class="c1"># something that can be serialzed as a nodeID for N3</span>
    <span class="c1">#</span>
    <span class="c1"># BNode identifiers must be valid NCNames&quot; _:[A-Za-z][A-Za-z0-9]*</span>
    <span class="c1"># http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/#nodeID</span>
    <span class="k">return</span> <span class="s2">&quot;N&quot;</span>  <span class="c1"># ensure that id starts with a letter</span>


<span class="k">def</span> <span class="nf">_serial_number_generator</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates UUID4-based but ncname-compliant identifiers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">uuid</span> <span class="k">import</span> <span class="n">uuid4</span>

    <span class="k">def</span> <span class="nf">_generator</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span>

    <span class="k">return</span> <span class="n">_generator</span>


<span class="k">class</span> <span class="nc">BNode</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Blank Node: http://www.w3.org/TR/rdf-concepts/#section-blank-nodes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">_sn_gen</span><span class="o">=</span><span class="n">_serial_number_generator</span><span class="p">(),</span> <span class="n">_prefix</span><span class="o">=</span><span class="n">_unique_id</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # only store implementations should pass in a value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># so that BNode values do not collide with ones created with</span>
            <span class="c1"># a different instance of this module at some other time.</span>
            <span class="n">node_id</span> <span class="o">=</span> <span class="n">_sn_gen</span><span class="p">()</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_prefix</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: check that value falls within acceptable bnode value range</span>
            <span class="c1"># for RDF/XML needs to be something that can be serialzed</span>
            <span class="c1"># as a nodeID for N3 ??  Unless we require these</span>
            <span class="c1"># constraints be enforced elsewhere?</span>
            <span class="k">pass</span>  <span class="c1"># assert is_ncname(unicode(value)), &quot;BNode identifiers</span>
                 <span class="c1"># must be valid NCNames&quot; _:[A-Za-z][A-Za-z0-9]*</span>
                 <span class="c1"># http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/#nodeID</span>
        <span class="k">return</span> <span class="n">Identifier</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;_:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">BNode</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">py3compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">BNode</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">&quot;rdflib.term.BNode&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">(&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">md5_term_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a string of hex that will be the same for two BNodes that</span>
<span class="sd">        are the same. It is not a suitable unique id.</span>

<span class="sd">        Supported for backwards compatibility; new code should</span>
<span class="sd">        probably just use __hash__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;method md5_term_hash is deprecated, and will be removed &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;in the future. If you use this please let rdflib-dev know!&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">skolemize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">authority</span><span class="o">=</span><span class="s2">&quot;http://rdlib.net/&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a URIRef &quot;skolem&quot; representation of the BNode, in accordance</span>
<span class="sd">        with http://www.w3.org/TR/rdf11-concepts/#section-skolemization</span>

<span class="sd">        .. versionadded:: 4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">skolem</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rdflib_skolem_genid</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">urljoin</span><span class="p">(</span><span class="n">authority</span><span class="p">,</span> <span class="n">skolem</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    RDF Literal: http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal</span>

<span class="s2">    The lexical value of the literal is the unicode object</span>
<span class="s2">    The interpreted, datatyped value is available from .value</span>

<span class="s2">    Language tags must be valid according to :rfc:5646</span>

<span class="s2">    For valid XSD datatypes, the lexical form is optionally normalized</span>
<span class="s2">    at construction time. Default behaviour is set by rdflib.NORMALIZE_LITERALS</span>
<span class="s2">    and can be overridden by the normalize parameter to __new__</span>

<span class="s2">    Equality and hashing of Literals are done based on the lexical form, i.e.:</span>

<span class="s2">    &gt;&gt;&gt; from rdflib.namespace import XSD</span>

<span class="s2">    &gt;&gt;&gt; Literal(&#39;01&#39;)!=Literal(&#39;1&#39;) # clear - strings differ</span>
<span class="s2">    True</span>

<span class="s2">    but with data-type they get normalized:</span>

<span class="s2">    &gt;&gt;&gt; Literal(&#39;01&#39;, datatype=XSD.integer)!=Literal(&#39;1&#39;, datatype=XSD.integer)</span>
<span class="s2">    False</span>

<span class="s2">    unless disabled:</span>

<span class="s2">    &gt;&gt;&gt; Literal(&#39;01&#39;, datatype=XSD.integer, normalize=False)!=Literal(&#39;1&#39;, datatype=XSD.integer)</span>
<span class="s2">    True</span>


<span class="s2">    Value based comparison is possible:</span>

<span class="s2">    &gt;&gt;&gt; Literal(&#39;01&#39;, datatype=XSD.integer).eq(Literal(&#39;1&#39;, datatype=XSD.float))</span>
<span class="s2">    True</span>

<span class="s2">    The eq method also provides limited support for basic python types:</span>

<span class="s2">    &gt;&gt;&gt; Literal(1).eq(1) # fine - int compatible with xsd:integer</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;a&#39;).eq(&#39;b&#39;) # fine - str compatible with plain-lit</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;a&#39;, datatype=XSD.string).eq(&#39;a&#39;) # fine - str compatible with xsd:string</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;a&#39;).eq(1) # not fine, int incompatible with plain-lit</span>
<span class="s2">    NotImplemented</span>

<span class="s2">    Greater-than/less-than ordering comparisons are also done in value</span>
<span class="s2">    space, when compatible datatypes are used.  Incompatible datatypes</span>
<span class="s2">    are ordered by DT, or by lang-tag.  For other nodes the ordering</span>
<span class="s2">    is None &lt; BNode &lt; URIRef &lt; Literal</span>

<span class="s2">    Any comparison with non-rdflib Node are &quot;NotImplemented&quot;</span>
<span class="s2">    In PY2.X some stable order will be made up by python</span>

<span class="s2">    In PY3 this is an error.</span>

<span class="s2">    &gt;&gt;&gt; from rdflib import Literal, XSD</span>
<span class="s2">    &gt;&gt;&gt; lit2006 = Literal(&#39;2006-01-01&#39;,datatype=XSD.date)</span>
<span class="s2">    &gt;&gt;&gt; lit2006.toPython()</span>
<span class="s2">    datetime.date(2006, 1, 1)</span>
<span class="s2">    &gt;&gt;&gt; lit2006 &lt; Literal(&#39;2007-01-01&#39;,datatype=XSD.date)</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal(datetime.utcnow()).datatype</span>
<span class="s2">    rdflib.term.URIRef(</span><span class="si">%(u)s</span><span class="s2">&#39;http://www.w3.org/2001/XMLSchema#dateTime&#39;)</span>
<span class="s2">    &gt;&gt;&gt; Literal(1) &gt; Literal(2) # by value</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(1) &gt; Literal(2.0) # by value</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;1&#39;) &gt; Literal(1) # by DT</span>
<span class="s2">    True</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;1&#39;) &lt; Literal(&#39;1&#39;) # by lexical form</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(&#39;a&#39;, lang=&#39;en&#39;) &gt; Literal(&#39;a&#39;, lang=&#39;fr&#39;) # by lang-tag</span>
<span class="s2">    False</span>
<span class="s2">    &gt;&gt;&gt; Literal(1) &gt; URIRef(&#39;foo&#39;) # by node-type</span>
<span class="s2">    True</span>

<span class="s2">    The &gt; &lt; operators will eat this NotImplemented and either make up</span>
<span class="s2">    an ordering (py2.x) or throw a TypeError (py3k):</span>

<span class="s2">    &gt;&gt;&gt; Literal(1).__gt__(2.0)</span>
<span class="s2">    NotImplemented</span>


<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">py3compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;language&quot;</span><span class="p">,</span> <span class="s2">&quot;datatype&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="s2">&quot;_language&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;_datatype&quot;</span><span class="p">,</span> <span class="s2">&quot;_value&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_language&quot;</span><span class="p">,</span> <span class="s2">&quot;_datatype&quot;</span><span class="p">,</span> <span class="s2">&quot;_value&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">lang</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># no empty lang-tags in RDF</span>

        <span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span> <span class="k">if</span> <span class="n">normalize</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">rdflib</span><span class="o">.</span><span class="n">NORMALIZE_LITERALS</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">datatype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;A Literal can only have one of lang or datatype, &quot;</span>
                <span class="s2">&quot;per http://www.w3.org/TR/rdf-concepts/#section-Graph-Literal&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_valid_langtag</span><span class="p">(</span><span class="n">lang</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid language tag!&quot;</span><span class="o">%</span><span class="n">lang</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">datatype</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="c1"># create from another Literal instance</span>

            <span class="n">lang</span> <span class="o">=</span> <span class="n">lang</span> <span class="ow">or</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">language</span>
            <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
                <span class="c1"># override datatype</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_castLexicalToPython</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">datatype</span> <span class="o">=</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">datatype</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">value</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># passed a string</span>
                <span class="c1"># try parsing lexical form of datatyped literal</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_castLexicalToPython</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="n">_value</span><span class="p">,</span> <span class="n">_datatype</span> <span class="o">=</span> <span class="n">_castPythonToLiteral</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_is_valid_unicode</span><span class="p">(</span><span class="n">_value</span><span class="p">):</span>
                        <span class="n">lexical_or_value</span> <span class="o">=</span> <span class="n">_value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># passed some python object</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">lexical_or_value</span>
            <span class="n">_value</span><span class="p">,</span> <span class="n">_datatype</span> <span class="o">=</span> <span class="n">_castPythonToLiteral</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">)</span>

            <span class="n">datatype</span> <span class="o">=</span> <span class="n">datatype</span> <span class="ow">or</span> <span class="n">_datatype</span>
            <span class="k">if</span> <span class="n">_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lexical_or_value</span> <span class="o">=</span> <span class="n">_value</span>
            <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
                <span class="n">lang</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">py3compat</span><span class="o">.</span><span class="n">PY3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexical_or_value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="n">lexical_or_value</span> <span class="o">=</span> <span class="n">lexical_or_value</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lexical_or_value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lexical_or_value</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="n">inst</span><span class="o">.</span><span class="n">_language</span> <span class="o">=</span> <span class="n">lang</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">_datatype</span> <span class="o">=</span> <span class="n">datatype</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">inst</span>

    <span class="nd">@py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span>
    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new literal with a normalised lexical representation</span>
<span class="sd">        of this literal</span>
<span class="sd">        &gt;&gt;&gt; from rdflib import XSD</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;01&quot;, datatype=XSD.integer, normalize=False).normalize()</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;1&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        Illegal lexical forms for the datatype given are simply passed on</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;a&quot;, datatype=XSD.integer, normalize=False)</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;a&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">language</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_language</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">datatype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_datatype</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_language</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;language&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datatype</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;datatype&quot;</span><span class="p">]</span>

    <span class="nd">@py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; Literal(1) + 1</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;2&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;) + &quot;1&quot;</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;11&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">py</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toPython</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">py</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># fall-through</span>

        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the Literal &quot;True&quot;</span>
<span class="sd">        This is used for if statements, bool(literal), etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="nd">@py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span>
    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; (- Literal(1))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;-1&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>
<span class="sd">        &gt;&gt;&gt; (- Literal(10.5))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;-10.5&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#double&#39;))</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; (- Literal(&quot;1&quot;, datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;-1&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; (- Literal(&quot;1&quot;))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(%(u)s&#39;1&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__neg__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a number; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="nd">@py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span>
    <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; (+ Literal(1))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;1&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>
<span class="sd">        &gt;&gt;&gt; (+ Literal(-1))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;-1&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; (+ Literal(&quot;-1&quot;, datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;-1&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; (+ Literal(&quot;1&quot;))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(%(u)s&#39;1&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__pos__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a number; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="nd">@py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span>
    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; abs(Literal(-1))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;1&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; abs( Literal(&quot;-1&quot;, datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;1&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; abs(Literal(&quot;1&quot;))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(%(u)s&#39;1&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__abs__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a number; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="nd">@py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span>
    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; ~(Literal(-1))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;0&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; ~( Literal(&quot;-1&quot;, datatype=XSD.integer))</span>
<span class="sd">        rdflib.term.Literal(%(u)s&#39;0&#39;, datatype=rdflib.term.URIRef(%(u)s&#39;http://www.w3.org/2001/XMLSchema#integer&#39;))</span>

<span class="sd">        Not working:</span>

<span class="sd">        &gt;&gt;&gt; ~(Literal(&quot;1&quot;))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">        TypeError: Not a number; rdflib.term.Literal(%(u)s&#39;1&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="fm">__invert__</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a number; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        This implements ordering for Literals,</span>
<span class="sd">        the other comparison methods delegate here</span>

<span class="sd">        This tries to implement this:</span>
<span class="sd">        http://www.w3.org/TR/sparql11-query/#modOrderBy</span>

<span class="sd">        In short, Literals with compatible data-types are orderd in value space,</span>
<span class="sd">        i.e.</span>
<span class="sd">        &gt;&gt;&gt; from rdflib import XSD</span>

<span class="sd">        &gt;&gt;&gt; Literal(1)&gt;Literal(2) # int/int</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal(2.0)&gt;Literal(1) # double/int</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; from decimal import Decimal</span>
<span class="sd">        &gt;&gt;&gt; Literal(Decimal(&quot;3.3&quot;)) &gt; Literal(2.0) # decimal/double</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(Decimal(&quot;3.3&quot;)) &lt; Literal(4.0) # decimal/double</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;b&#39;)&gt;Literal(&#39;a&#39;) # plain lit/plain lit</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;b&#39;)&gt;Literal(&#39;a&#39;, datatype=XSD.string) # plain lit/xsd:string</span>
<span class="sd">        True</span>

<span class="sd">        Incompatible datatype mismatches ordered by DT</span>

<span class="sd">        &gt;&gt;&gt; Literal(1)&gt;Literal(&quot;2&quot;) # int&gt;string</span>
<span class="sd">        False</span>

<span class="sd">        Langtagged literals by lang tag</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;a&quot;, lang=&quot;en&quot;)&gt;Literal(&quot;a&quot;, lang=&quot;fr&quot;)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Everything is greater than None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span> <span class="ow">and</span> \
                    <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numeric_greater</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># plain-literals and xsd:string literals</span>
            <span class="c1"># are &quot;the same&quot;</span>
            <span class="n">dtself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>
            <span class="n">dtother</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>

            <span class="k">if</span> <span class="n">dtself</span> <span class="o">!=</span> <span class="n">dtother</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rdflib</span><span class="o">.</span><span class="n">DAWG_LITERAL_COLLATION</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">NotImplemented</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dtself</span> <span class="o">&gt;</span> <span class="n">dtother</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>

            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="c1"># same language, same lexical form, check real dt</span>
            <span class="c1"># plain-literals come before xsd:string!</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span>

            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># they are the same</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Literal are the greatest!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># we can only compare to nodes</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Nothing is less than None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># all nodes are less-than Literals</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;2007-01-01T10:00:00&#39;, datatype=XSD.dateTime</span>
<span class="sd">        ...     ) &lt;= Literal(&#39;2007-01-01T10:00:00&#39;, datatype=XSD.dateTime)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_comparable_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to decide which things are meaningful to</span>
<span class="sd">        rich-compare with this literal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">):</span>
                <span class="c1"># two datatyped literals</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">XSDToPython</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">XSDToPython</span><span class="p">:</span>
                    <span class="c1"># non XSD DTs must match</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># xsd:string may be compared with plain literals</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="c1"># if given lang-tag has to be case insensitive equal</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; from rdflib.namespace import XSD</span>
<span class="sd">        &gt;&gt;&gt; a = {Literal(&#39;1&#39;, datatype=XSD.integer):&#39;one&#39;}</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;1&#39;, datatype=XSD.double) in a</span>
<span class="sd">        False</span>


<span class="sd">        &quot;Called for the key object for dictionary operations,</span>
<span class="sd">        and by the built-in function hash(). Should return</span>
<span class="sd">        a 32-bit integer usable as a hash value for</span>
<span class="sd">        dictionary operations. The only required property</span>
<span class="sd">        is that objects which compare equal have the same</span>
<span class="sd">        hash value; it is advised to somehow mix together</span>
<span class="sd">        (e.g., using exclusive or) the hash values for the</span>
<span class="sd">        components of the object that also play a part in</span>
<span class="sd">        comparison of objects.&quot; -- 3.4.1 Basic customization (Python)</span>

<span class="sd">        &quot;Two literals are equal if and only if all of the following hold:</span>
<span class="sd">        * The strings of the two lexical forms compare equal, character by</span>
<span class="sd">        character.</span>
<span class="sd">        * Either both or neither have language tags.</span>
<span class="sd">        * The language tags, if any, compare equal.</span>
<span class="sd">        * Either both or neither have datatype URIs.</span>
<span class="sd">        * The two datatype URIs, if any, compare equal, character by</span>
<span class="sd">        character.&quot;</span>
<span class="sd">        -- 6.5.1 Literal Equality (RDF: Concepts and Abstract Syntax)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">^=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Literals are only equal to other literals.</span>

<span class="sd">        &quot;Two literals are equal if and only if all of the following hold:</span>
<span class="sd">        * The strings of the two lexical forms compare equal, character by character.</span>
<span class="sd">        * Either both or neither have language tags.</span>
<span class="sd">        * The language tags, if any, compare equal.</span>
<span class="sd">        * Either both or neither have datatype URIs.</span>
<span class="sd">        * The two datatype URIs, if any, compare equal, character by character.&quot;</span>
<span class="sd">        -- 6.5.1 Literal Equality (RDF: Concepts and Abstract Syntax)</span>

<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;)) == Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;)) == Literal(&quot;1&quot;, datatype=URIRef(&quot;foo2&quot;))</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;)) == Literal(&quot;2&quot;, datatype=URIRef(&quot;foo&quot;))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=URIRef(&quot;foo&quot;)) == &quot;asdf&quot;</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; from rdflib import XSD</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;2007-01-01&#39;, datatype=XSD.date) == Literal(&#39;2007-01-01&#39;, datatype=XSD.date)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&#39;2007-01-01&#39;, datatype=XSD.date) == date(2007, 1, 1)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;one&quot;, lang=&quot;en&quot;) == Literal(&quot;one&quot;, lang=&quot;en&quot;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;hast&quot;, lang=&#39;en&#39;) == Literal(&quot;hast&quot;, lang=&#39;de&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=XSD.integer) == Literal(1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=XSD.integer) == Literal(&quot;01&quot;, datatype=XSD.integer)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">language</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">language</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare the value of this literal with something else</span>

<span class="sd">        Either, with the value of another literal</span>
<span class="sd">        comparisons are then done in literal &quot;value space&quot;,</span>
<span class="sd">        and according to the rules of XSD subtype-substitution/type-promotion</span>

<span class="sd">        OR, with a python object:</span>

<span class="sd">        basestring objects can be compared with plain-literals,</span>
<span class="sd">        or those with datatype xsd:string</span>

<span class="sd">        bool objects with xsd:boolean</span>

<span class="sd">        a int, long or float with numeric xsd types</span>

<span class="sd">        isodate date,time,datetime objects with xsd:date,xsd:time or xsd:datetime</span>

<span class="sd">        Any other operations returns NotImplemented</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Literal</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span>  \
                    <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;I cannot know that these two lexical forms do not map to the same value: </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">language</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">dtself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>
            <span class="n">dtother</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">or</span> <span class="n">_XSD_STRING</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dtself</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">and</span> <span class="n">dtother</span> <span class="o">==</span> <span class="n">_XSD_STRING</span><span class="p">):</span>
                <span class="c1"># string/plain literals, compare on lexical form</span>
                <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dtself</span> <span class="o">!=</span> <span class="n">dtother</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rdflib</span><span class="o">.</span><span class="n">DAWG_LITERAL_COLLATION</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;I don&#39;t know how to compare literals with datatypes </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># matching non-string DTs now - do we compare values or</span>
            <span class="c1"># lexical form first?  comparing two ints is far quicker -</span>
            <span class="c1"># maybe there are counter examples</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_RDF_XMLLITERAL</span><span class="p">,</span> <span class="n">_RDF_HTMLLITERAL</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_isEqualXMLNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># string value space=lexical space</span>

                <span class="c1"># matching DTs, but not matching, we cannot compare!</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;I cannot know that these two lexical forms do not map to the same value: </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># no non-Literal nodes are equal to a literal</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># only plain-literals can be directly compared to strings</span>

            <span class="c1"># TODO: Is &quot;blah&quot;@en eq &quot;blah&quot; ?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_STRING</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">time</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_XSD_DATETIME</span><span class="p">,</span> <span class="n">_XSD_DATE</span><span class="p">,</span> <span class="n">_XSD_TIME</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_BOOLEAN</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">neq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span>
    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a representation in the N3 format.</span>

<span class="sd">        Examples::</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;foo&quot;).n3()</span>
<span class="sd">            %(u)s&#39;&quot;foo&quot;&#39;</span>

<span class="sd">        Strings with newlines or triple-quotes::</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;foo\nbar&quot;).n3()</span>
<span class="sd">            %(u)s&#39;&quot;&quot;&quot;foo\nbar&quot;&quot;&quot;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;&#39;&#39;\&#39;&quot;).n3()</span>
<span class="sd">            %(u)s&#39;&quot;\&#39;\&#39;\&#39;&quot;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(&#39;&quot;&quot;&quot;&#39;).n3()</span>
<span class="sd">            %(u)s&#39;&quot;\\&quot;\\&quot;\\&quot;&quot;&#39;</span>

<span class="sd">        Language::</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;hello&quot;, lang=&quot;en&quot;).n3()</span>
<span class="sd">            %(u)s&#39;&quot;hello&quot;@en&#39;</span>

<span class="sd">        Datatypes::</span>

<span class="sd">            &gt;&gt;&gt; Literal(1).n3()</span>
<span class="sd">            %(u)s&#39;&quot;1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0).n3()</span>
<span class="sd">            %(u)s&#39;&quot;1.0&quot;^^&lt;http://www.w3.org/2001/XMLSchema#double&gt;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(True).n3()</span>
<span class="sd">            %(u)s&#39;&quot;true&quot;^^&lt;http://www.w3.org/2001/XMLSchema#boolean&gt;&#39;</span>

<span class="sd">        Datatype and language isn&#39;t allowed (datatype takes precedence)::</span>

<span class="sd">            &gt;&gt;&gt; Literal(1, lang=&quot;en&quot;).n3()</span>
<span class="sd">            %(u)s&#39;&quot;1&quot;^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;&#39;</span>

<span class="sd">        Custom datatype::</span>

<span class="sd">            &gt;&gt;&gt; footype = URIRef(&quot;http://example.org/ns#foo&quot;)</span>
<span class="sd">            &gt;&gt;&gt; Literal(&quot;1&quot;, datatype=footype).n3()</span>
<span class="sd">            %(u)s&#39;&quot;1&quot;^^&lt;http://example.org/ns#foo&gt;&#39;</span>

<span class="sd">        Passing a namespace-manager will use it to abbreviate datatype URIs:</span>

<span class="sd">            &gt;&gt;&gt; from rdflib import Graph</span>
<span class="sd">            &gt;&gt;&gt; Literal(1).n3(Graph().namespace_manager)</span>
<span class="sd">            %(u)s&#39;&quot;1&quot;^^xsd:integer&#39;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">namespace_manager</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">(</span><span class="n">qname_callback</span> <span class="o">=</span>
                                    <span class="n">namespace_manager</span><span class="o">.</span><span class="n">normalizeUri</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">()</span>

    <span class="nd">@py3compat</span><span class="o">.</span><span class="n">format_doctest_out</span>
    <span class="k">def</span> <span class="nf">_literal_n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_plain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">qname_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Using plain literal (shorthand) output::</span>
<span class="sd">            &gt;&gt;&gt; from rdflib.namespace import XSD</span>

<span class="sd">            &gt;&gt;&gt; Literal(1)._literal_n3(use_plain=True)</span>
<span class="sd">            %(u)s&#39;1&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0)._literal_n3(use_plain=True)</span>
<span class="sd">            %(u)s&#39;1e+00&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0, datatype=XSD.decimal)._literal_n3(use_plain=True)</span>
<span class="sd">            %(u)s&#39;1.0&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.0, datatype=XSD.float)._literal_n3(use_plain=True)</span>
<span class="sd">            %(u)s&#39;&quot;1.0&quot;^^&lt;http://www.w3.org/2001/XMLSchema#float&gt;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(&quot;foo&quot;, datatype=XSD.string)._literal_n3(</span>
<span class="sd">            ...         use_plain=True)</span>
<span class="sd">            %(u)s&#39;&quot;foo&quot;^^&lt;http://www.w3.org/2001/XMLSchema#string&gt;&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(True)._literal_n3(use_plain=True)</span>
<span class="sd">            %(u)s&#39;true&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(False)._literal_n3(use_plain=True)</span>
<span class="sd">            %(u)s&#39;false&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(1.91)._literal_n3(use_plain=True)</span>
<span class="sd">            %(u)s&#39;1.91e+00&#39;</span>

<span class="sd">            Only limited precision available for floats:</span>
<span class="sd">            &gt;&gt;&gt; Literal(0.123456789)._literal_n3(use_plain=True)</span>
<span class="sd">            %(u)s&#39;1.234568e-01&#39;</span>

<span class="sd">            &gt;&gt;&gt; Literal(&#39;0.123456789&#39;,</span>
<span class="sd">            ...     datatype=XSD.decimal)._literal_n3(use_plain=True)</span>
<span class="sd">            %(u)s&#39;0.123456789&#39;</span>

<span class="sd">        Using callback for datatype QNames::</span>

<span class="sd">            &gt;&gt;&gt; Literal(1)._literal_n3(</span>
<span class="sd">            ...         qname_callback=lambda uri: &quot;xsd:integer&quot;)</span>
<span class="sd">            %(u)s&#39;&quot;1&quot;^^xsd:integer&#39;</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">use_plain</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_PLAIN_LITERAL_TYPES</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If self is inf or NaN, we need a datatype</span>
                <span class="c1"># (there is no plain representation)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_INF_NAN_LITERAL_TYPES</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">qname_callback</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literal_n3</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">qname_callback</span><span class="p">)</span>

                <span class="c1"># this is a bit of a mess -</span>
                <span class="c1"># in py &gt;=2.6 the string.format function makes this easier</span>
                <span class="c1"># we try to produce &quot;pretty&quot; output</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_DOUBLE</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sub</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">.?0*e&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_DECIMAL</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span>
                    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;.0&#39;</span>
                    <span class="k">return</span> <span class="n">s</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">==</span> <span class="n">_XSD_BOOLEAN</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span>

        <span class="n">encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quote_encode</span><span class="p">()</span>

        <span class="n">datatype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span>
        <span class="n">quoted_dt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qname_callback</span><span class="p">:</span>
                <span class="n">quoted_dt</span> <span class="o">=</span> <span class="n">qname_callback</span><span class="p">(</span><span class="n">datatype</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">quoted_dt</span><span class="p">:</span>
                <span class="n">quoted_dt</span> <span class="o">=</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">datatype</span>
            <span class="k">if</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="n">_NUMERIC_INF_NAN_LITERAL_TYPES</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="c1"># py string reps: float: &#39;inf&#39;, Decimal: &#39;Infinity&quot;</span>
                        <span class="c1"># both need to become &quot;INF&quot; in xsd datatypes</span>
                        <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">,</span> <span class="s1">&#39;INF&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s1">&#39;Infinity&#39;</span><span class="p">,</span> <span class="s1">&#39;INF&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                        <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">,</span> <span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># if we can&#39;t cast to float something is wrong, but we can</span>
                    <span class="c1"># still serialize. Warn user about it</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Serializing weird numerical </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">language</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span>
        <span class="k">if</span> <span class="n">language</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">@</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">datatype</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">^^</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">quoted_dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">encoded</span>

    <span class="k">def</span> <span class="nf">_quote_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This simpler encoding doesn&#39;t work; a newline gets encoded as &quot;\\n&quot;,</span>
        <span class="c1"># which is ok in sourcecode, but we want &quot;\n&quot;.</span>
        <span class="c1"># encoded = self.encode(&#39;unicode-escape&#39;).replace(</span>
        <span class="c1">#        &#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;&quot;&#39;,&#39;\\&quot;&#39;)</span>
        <span class="c1"># encoded = self.replace.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;&quot;&#39;,&#39;\\&quot;&#39;)</span>

        <span class="c1"># NOTE: Could in theory chose quotes based on quotes appearing in the</span>
        <span class="c1"># string, i.e. &#39;&quot;&#39; and &quot;&#39;&quot;, but N3/turtle doesn&#39;t allow &quot;&#39;&quot;(?).</span>

        <span class="k">if</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Triple quote this string.</span>
            <span class="n">encoded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="c1"># is this ok?</span>
                <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;</span><span class="se">\\</span><span class="s1">&quot;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">encoded</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span> <span class="ow">and</span> <span class="n">encoded</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="n">encoded</span> <span class="o">=</span> <span class="n">encoded</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span>

            <span class="k">return</span> <span class="s1">&#39;&quot;&quot;&quot;</span><span class="si">%s</span><span class="s1">&quot;&quot;&quot;&#39;</span> <span class="o">%</span> <span class="n">encoded</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">r&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">r&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">py3compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span><span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;lang=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;datatype=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Literal</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">&quot;rdflib.term.Literal&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an appropriate python datatype derived from this RDF Literal</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">md5_term_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a string of hex that will be the same for two Literals that</span>
<span class="sd">        are the same. It is not a suitable unique id.</span>

<span class="sd">        Supported for backwards compatibility; new code should</span>
<span class="sd">        probably just use __hash__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;method md5_term_hash is deprecated, and will be removed &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;removed in the future. If you use this please let rdflib-dev know!&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_parseXML</span><span class="p">(</span><span class="n">xmlstring</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">py3compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="n">xmlstring</span> <span class="o">=</span> <span class="n">xmlstring</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span>
        <span class="s2">&quot;&lt;rdflibtoplevelelement&gt;</span><span class="si">%s</span><span class="s2">&lt;/rdflibtoplevelelement&gt;&quot;</span> <span class="o">%</span> <span class="n">xmlstring</span><span class="p">)</span>
    <span class="n">retval</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">retval</span>


<span class="k">def</span> <span class="nf">_parseHTML</span><span class="p">(</span><span class="n">htmltext</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">html5lib</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">html5lib</span><span class="o">.</span><span class="n">HTMLParser</span><span class="p">(</span>
            <span class="n">tree</span><span class="o">=</span><span class="n">html5lib</span><span class="o">.</span><span class="n">treebuilders</span><span class="o">.</span><span class="n">getTreeBuilder</span><span class="p">(</span><span class="s2">&quot;dom&quot;</span><span class="p">))</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parseFragment</span><span class="p">(</span><span class="n">htmltext</span><span class="p">)</span>
        <span class="n">retval</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">retval</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">&quot;HTML5 parser not available. Try installing&quot;</span> <span class="o">+</span>
            <span class="s2">&quot; html5lib &lt;http://code.google.com/p/html5lib&gt;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_writeXML</span><span class="p">(</span><span class="n">xmlnode</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xmlnode</span><span class="p">,</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">DocumentFragment</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">Document</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">childNodes</span> <span class="o">+=</span> <span class="n">xmlnode</span><span class="o">.</span><span class="n">childNodes</span>
        <span class="n">xmlnode</span> <span class="o">=</span> <span class="n">d</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">xmlnode</span><span class="o">.</span><span class="n">toxml</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="c1"># for clean round-tripping, remove headers -- I have great and</span>
    <span class="c1"># specific worries that this will blow up later, but this margin</span>
    <span class="c1"># is too narrow to contain them</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s1">&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#39;</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">38</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s1">&#39;&lt;rdflibtoplevelelement&gt;&#39;</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">23</span><span class="p">:</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">b</span><span class="p">(</span><span class="s1">&#39;&lt;rdflibtoplevelelement/&gt;&#39;</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">b</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="c1"># Cannot import Namespace/XSD because of circular dependencies</span>
<span class="n">_XSD_PFX</span> <span class="o">=</span> <span class="s1">&#39;http://www.w3.org/2001/XMLSchema#&#39;</span>
<span class="n">_RDF_PFX</span> <span class="o">=</span> <span class="s1">&#39;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#39;</span>

<span class="n">_RDF_XMLLITERAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_RDF_PFX</span> <span class="o">+</span> <span class="s1">&#39;XMLLiteral&#39;</span><span class="p">)</span>
<span class="n">_RDF_HTMLLITERAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_RDF_PFX</span> <span class="o">+</span> <span class="s1">&#39;HTML&#39;</span><span class="p">)</span>

<span class="n">_XSD_STRING</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span>

<span class="n">_XSD_FLOAT</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="n">_XSD_DOUBLE</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;double&#39;</span><span class="p">)</span>
<span class="n">_XSD_DECIMAL</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;decimal&#39;</span><span class="p">)</span>
<span class="n">_XSD_INTEGER</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;integer&#39;</span><span class="p">)</span>
<span class="n">_XSD_BOOLEAN</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;boolean&#39;</span><span class="p">)</span>

<span class="n">_XSD_DATETIME</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;dateTime&#39;</span><span class="p">)</span>
<span class="n">_XSD_DATE</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;date&#39;</span><span class="p">)</span>
<span class="n">_XSD_TIME</span> <span class="o">=</span> <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;time&#39;</span><span class="p">)</span>

<span class="c1"># TODO: duration, gYearMonth, gYear, gMonthDay, gDay, gMonth</span>

<span class="n">_NUMERIC_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_XSD_INTEGER</span><span class="p">,</span>
    <span class="n">_XSD_DECIMAL</span><span class="p">,</span>
    <span class="n">_XSD_DOUBLE</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;float&#39;</span><span class="p">),</span>

    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;byte&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;int&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;long&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;negativeInteger&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;nonNegativeInteger&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;nonPositiveInteger&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;positiveInteger&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;short&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedByte&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedInt&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedLong&#39;</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedShort&#39;</span><span class="p">),</span>

<span class="p">)</span>

<span class="c1"># these have &quot;native&quot; syntax in N3/SPARQL</span>
<span class="n">_PLAIN_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_XSD_INTEGER</span><span class="p">,</span>
    <span class="n">_XSD_BOOLEAN</span><span class="p">,</span>
    <span class="n">_XSD_DOUBLE</span><span class="p">,</span>
    <span class="n">_XSD_DECIMAL</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># these have special INF and NaN XSD representations</span>
<span class="n">_NUMERIC_INF_NAN_LITERAL_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;float&#39;</span><span class="p">),</span>
    <span class="n">_XSD_DOUBLE</span><span class="p">,</span>
    <span class="n">_XSD_DECIMAL</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_castPythonToLiteral</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Casts a python datatype to a tuple of the lexical value and a</span>
<span class="sd">    datatype URI (or None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">pType</span><span class="p">,</span> <span class="p">(</span><span class="n">castFunc</span><span class="p">,</span> <span class="n">dType</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_PythonToXSD</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">pType</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">castFunc</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">castFunc</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">dType</span>
            <span class="k">elif</span> <span class="n">dType</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">dType</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="kc">None</span>  <span class="c1"># TODO: is this right for the fall through case?</span>

<span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span>

<span class="c1"># Mappings from Python types to XSD datatypes and back (borrowed from sparta)</span>
<span class="c1"># datetime instances are also instances of date... so we need to order these.</span>

<span class="c1"># SPARQL/Turtle/N3 has shortcuts for integer, double, decimal</span>
<span class="c1"># python has only float - to be in tune with sparql/n3/turtle</span>
<span class="c1"># we default to XSD.double for float literals</span>

<span class="c1"># python ints are promoted to longs when overflowing</span>
<span class="c1"># python longs have no limit</span>
<span class="c1"># both map to the abstract integer type,</span>
<span class="c1"># rather than some concrete bit-limited datatype</span>

<span class="n">_PythonToXSD</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_DOUBLE</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">_XSD_BOOLEAN</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_INTEGER</span><span class="p">)),</span>
    <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_INTEGER</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_XSD_DECIMAL</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">datetime</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="n">_XSD_DATETIME</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="n">_XSD_DATE</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(),</span> <span class="n">_XSD_TIME</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">Document</span><span class="p">,</span> <span class="p">(</span><span class="n">_writeXML</span><span class="p">,</span> <span class="n">_RDF_XMLLITERAL</span><span class="p">)),</span>
    <span class="c1"># this is a bit dirty - by accident the html5lib parser produces</span>
    <span class="c1"># DocumentFragments, and the xml parser Documents, letting this</span>
    <span class="c1"># decide what datatype to use makes roundtripping easier, but it a</span>
    <span class="c1"># bit random</span>
    <span class="p">(</span><span class="n">xml</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">minidom</span><span class="o">.</span><span class="n">DocumentFragment</span><span class="p">,</span> <span class="p">(</span><span class="n">_writeXML</span><span class="p">,</span> <span class="n">_RDF_HTMLLITERAL</span><span class="p">))</span>
<span class="p">]</span>

<span class="n">XSDToPython</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kc">None</span> <span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># plain literals map directly to value space</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;time&#39;</span><span class="p">):</span> <span class="n">parse_time</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;date&#39;</span><span class="p">):</span> <span class="n">parse_date</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;gYear&#39;</span><span class="p">):</span> <span class="n">parse_date</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;gYearMonth&#39;</span><span class="p">):</span> <span class="n">parse_date</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;dateTime&#39;</span><span class="p">):</span> <span class="n">parse_datetime</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;string&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;normalizedString&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;token&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;language&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;boolean&#39;</span><span class="p">):</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">],</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;decimal&#39;</span><span class="p">):</span> <span class="n">Decimal</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;integer&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;nonPositiveInteger&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;long&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;nonNegativeInteger&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;negativeInteger&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;int&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedLong&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;positiveInteger&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;short&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedInt&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;byte&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedShort&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;unsignedByte&#39;</span><span class="p">):</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;float&#39;</span><span class="p">):</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;double&#39;</span><span class="p">):</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;base64Binary&#39;</span><span class="p">):</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
    <span class="n">URIRef</span><span class="p">(</span><span class="n">_XSD_PFX</span> <span class="o">+</span> <span class="s1">&#39;anyURI&#39;</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">_RDF_XMLLITERAL</span><span class="p">:</span> <span class="n">_parseXML</span><span class="p">,</span>
    <span class="n">_RDF_HTMLLITERAL</span><span class="p">:</span> <span class="n">_parseHTML</span>
<span class="p">}</span>

<span class="n">_toPythonMapping</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">_toPythonMapping</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">XSDToPython</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_castLexicalToPython</span><span class="p">(</span><span class="n">lexical</span><span class="p">,</span> <span class="n">datatype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map a lexical form to the value-space for the given datatype</span>
<span class="sd">    :returns: a python object for the value or ``None``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">convFunc</span> <span class="o">=</span> <span class="n">_toPythonMapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">datatype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">convFunc</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convFunc</span><span class="p">(</span><span class="n">lexical</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># not a valid lexical representation for this dt</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">convFunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># no conv func means 1-1 lexical&lt;-&gt;value-space mapping</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">lexical</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">lexical</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># no convFunc - unknown data-type</span>
        <span class="k">return</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">bind</span><span class="p">(</span><span class="n">datatype</span><span class="p">,</span> <span class="n">pythontype</span><span class="p">,</span> <span class="n">constructor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lexicalizer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    register a new datatype&lt;-&gt;pythontype binding</span>

<span class="sd">    :param constructor: an optional function for converting lexical forms</span>
<span class="sd">                        into a Python instances, if not given the pythontype</span>
<span class="sd">                        is used directly</span>

<span class="sd">    :param lexicalizer: an optinoal function for converting python objects to</span>
<span class="sd">                        lexical form, if not given object.__str__ is used</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">datatype</span> <span class="ow">in</span> <span class="n">_toPythonMapping</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;datatype &#39;</span><span class="si">%s</span><span class="s2">&#39; was already bound. Rebinding.&quot;</span> <span class="o">%</span>
                        <span class="n">datatype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">constructor</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">constructor</span> <span class="o">=</span> <span class="n">pythontype</span>
    <span class="n">_toPythonMapping</span><span class="p">[</span><span class="n">datatype</span><span class="p">]</span> <span class="o">=</span> <span class="n">constructor</span>
    <span class="n">_PythonToXSD</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pythontype</span><span class="p">,</span> <span class="p">(</span><span class="n">lexicalizer</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">Identifier</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Variable - this is used for querying, or in Formula aware</span>
<span class="sd">    graphs, where Variables can stored in the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Attempted to create variable with empty string as name!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;?&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">Variable</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="s2">&quot;rdflib.term.Variable&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clsName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">n3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace_manager</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>

    <span class="k">def</span> <span class="nf">md5_term_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;a string of hex that will be the same for two Variables that</span>
<span class="sd">        are the same. It is not a suitable unique id.</span>

<span class="sd">        Supported for backwards compatibility; new code should</span>
<span class="sd">        probably just use __hash__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;method md5_term_hash is deprecated, and will be removed &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;removed in the future. If you use this please let rdflib-dev know!&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;V&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Statement</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">xxx_todo_changeme</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Class Statement is deprecated, and will be removed in &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;the future. If you use this please let rdflib-dev know!&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">((</span><span class="n">subject</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span> <span class="n">context</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Statement</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">toPython</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Nodes are ordered like this</span>
<span class="c1"># See http://www.w3.org/TR/sparql11-query/#modOrderBy</span>
<span class="c1"># we leave &quot;space&quot; for more subclasses of Node elsewhere</span>
<span class="c1"># default-dict to grazefully fail for new subclasses</span>
<span class="n">_ORDERING</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">_ORDERING</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="n">BNode</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">Variable</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">URIRef</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">:</span> <span class="mi">40</span>
    <span class="p">})</span>


<span class="k">def</span> <span class="nf">_isEqualXMLNode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">xml.dom.minidom</span> <span class="k">import</span> <span class="n">Node</span>

    <span class="k">def</span> <span class="nf">recurse</span><span class="p">():</span>
        <span class="c1"># Recursion through the children</span>
        <span class="c1"># In Python2, the semantics of &#39;map&#39; is such that the check on</span>
        <span class="c1"># length would be unnecessary. In Python 3,</span>
        <span class="c1"># the semantics of map has changed (why, oh why???) and the check</span>
        <span class="c1"># for the length becomes necessary...</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">childNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">childNodes</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">oc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">childNodes</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">childNodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_isEqualXMLNode</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">oc</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># if we got here then everything is fine:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">nodeType</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Node</span><span class="o">.</span><span class="n">DOCUMENT_NODE</span><span class="p">,</span> <span class="n">Node</span><span class="o">.</span><span class="n">DOCUMENT_FRAGMENT_NODE</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">recurse</span><span class="p">()</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">ELEMENT_NODE</span><span class="p">:</span>
        <span class="c1"># Get the basics right</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tagName</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tagName</span>
                <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">namespaceURI</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">namespaceURI</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Handle the (namespaced) attributes; the namespace setting key</span>
        <span class="c1"># should be ignored, though</span>
        <span class="c1"># Note that the minidom orders the keys already, so we do not have</span>
        <span class="c1"># to worry about that, which is a bonus...</span>
        <span class="n">n_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keysNS</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;http://www.w3.org/2000/xmlns/&#39;</span><span class="p">]</span>
        <span class="n">o_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">keysNS</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;http://www.w3.org/2000/xmlns/&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_keys</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">n_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">o_keys</span>
                    <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">getAttributeNS</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">getAttributeNS</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># if we got here, the attributes are all right, we can go down</span>
        <span class="c1"># the tree recursively</span>
        <span class="k">return</span> <span class="n">recurse</span><span class="p">()</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">Node</span><span class="o">.</span><span class="n">TEXT_NODE</span><span class="p">,</span> <span class="n">Node</span><span class="o">.</span><span class="n">COMMENT_NODE</span><span class="p">,</span> <span class="n">Node</span><span class="o">.</span><span class="n">CDATA_SECTION_NODE</span><span class="p">,</span>
            <span class="n">Node</span><span class="o">.</span><span class="n">NOTATION_NODE</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">PROCESSING_INSTRUCTION_NODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">target</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">ENTITY_NODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeValue</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">nodeValue</span>

    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="n">DOCUMENT_TYPE_NODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">publicId</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">publicId</span> \
            <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">systemId</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">Id</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># should not happen, in fact</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s1">&#39;I dont know how to compare XML Node type: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="n">nodeType</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">mep-django</a></h1>



<p class="blurb">Django web application for Shakespeare & Company Project (Formerly Mapping Expatriate Paris)</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=Princeton-CDH&repo=mep-django&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/Princeton-CDH/mep-django">
    <img
        alt="https://secure.travis-ci.org/Princeton-CDH/mep-django.svg?branch=master"
        src="https://secure.travis-ci.org/Princeton-CDH/mep-django.svg?branch=master"
    />
</a>
</p>




    

<p>
<a class="badge" href="https://codecov.io/github/Princeton-CDH/mep-django">
    <img
    alt="https://codecov.io/github/Princeton-CDH/mep-django/coverage.svg?branch=master"
    src="https://codecov.io/github/Princeton-CDH/mep-django/coverage.svg?branch=master"
    />
</a>
</p>
<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../architecture.html">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../codedocs.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Change Log</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><div class="powered_by">
<p>Powered by:</p>
<a href="http://cdh.princeton.edu/">
<img src="https://cdh.princeton.edu/static/img/CDH_logo.svg"
    alt="Center for Digital Humanities @ Princeton" />
</a>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Trustees of Princeton University.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>